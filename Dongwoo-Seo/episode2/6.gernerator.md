# Generators

## generator-function

* 일반 함수는 function 키워드로 시작을 하지만, 제너레이터 함수는 function* 키워드로 시작
* 제너레이터 함수 안에는 yield 구문이 존재, return 과 비슷하지만 return의 경우를 해당 함수를 종료시키는 역할을 하지만 yield의 는 함수를 멈추는 역할을 한다.
```javascript
function* quips(name) {
  yield `안녕!`;
  yield `당신의 이름은 무엇인가요?`;
  if (name.startWith('서')) {
    yield `당신은 서씨 이군요!!! ${name}`;
  }
  yield `그럼 잘가요.`;
}

const iter = quips('서동우');  //제너레이터 객체를 티런

iter.next().value;    //안녕
iter.next().value;    //당신의 이름은 무엇인가요?
```
제너레이터 함수의 경우는 호출을 해도 바로 실행하지 않고, 멈춰진 상태의 제너레이터 객체(generator object)를 리턴한다.
그리고 next()를 호출할 때 마다 다음 번의 yield 구문까지 실행. 마지막의 yield 까지 호출하게 되면 done 이 true로 된다.
제너레이터의 동작은 동기적으로 싱글 쓰레드 환경에서 동작

## 제너레이터는 이터레이터
모든 제너레이터에는 .next() 코드와 [Symbol.iterator]() 코드를 내장하고 있음
```javascript
//이터레이터 예제
function range(start, stop) {
  return ({
    [Symbol.iterator]: function()  {
      return {
        data : start - 1,
        next : function() {
          this.data += 1;
          if (this.data <= stop) {
              return {
                done : false, value:this.data
              };
          } else {
              return {
                done : true
              };
          }
        }
      }
    } 
  });
}

function* range(start, stop) {
  for (var i = start; i < stop; i++)
    yield i;
}
```
위에서 보는 것과 같이 interator를 구현하는데 있어서 제너레이터가 보다 효과적이다.

```javascript
// 1차원 배열 'icons'를
// 'rowLength' 길이의 배열 여러개로 나눕니다.
function splitIntoRows(icons, rowLength) {
  var rows = [];
  for (var i = 0; i < icons.length; i += rowLength) {
    rows.push(icons.slice(i, i + rowLength));
  }
  return rows;
}
           
function* splitIntoRows(icons, rowLength) {
  for (var i = 0; i < icons.length; i += rowLength) {
    yield icons.slice(i, i + rowLength);
  }
}
```
실제 동작하는 것은 두 개가 같이 보이지만 실제로 동작하는 건 틀리다. 배열을 이용하는 방식은 전부 한번에 처리하는 것이고 제너레이터를 동작하는 방식은 동작할 때 마다 하나씩 리턴을 한다.
이러한 차이로 인해서 엄청나게 큰 결과를 처리한다던가 이런 경우 제너레이터를 사용하는 것도 좀 더 효율적 일 수 있다.

## 제너레이터의 종료 방식
1. generator.return()
2. generator.next()에 인자 전달
3. generator.throw(error)
4. yield*

```javascript
function* produceValues() {
  setup();
  try {
    // ... 뭔가 값을 yield 합시다 ...
  } finally {
    cleanup();
  }
}

for (var value of produceValues()) {
  work(value);
}
```
work(value)를 실행하는 중에 에러가 발생 시에 cleanup() 함수를 호출할까? 호출해준다.
이터레이터 객체에는 경우에 따라서 return(), throw() 함수를 선언할 수 있는데, 제너레이터도 이 메소드를 지원해서 중간에 에러 발생 시 return() 함수가 호출되어 finally 블럭의 코드를 실행하고 종료를 하게 된다. 

## yield 를 이용해서 비동기 --> 동기로 전환
```javascript
// generator function
function *generator () {
  var name = yield 'Barry';
  return name + ', says hello';
}

// iterator object
let iterator = generator();

iterator.next(); // { value: "Barry",  done: false }
iterator.next('Sue'); // { value: "Sue, says hello", done: true }

let getTweets = function* () {
  let totalTweets = [];
  let data;

  // pause. On `iterator.next()` get the 1st tweet and carry on.
  data = yield get('https://api.myjson.com/bins/2qjdn');
  totalTweets.push(data);

  // pause. On `iterator.next()` get the 2nd tweet and carry on.
  data = yield get('https://api.myjson.com/bins/3zjqz');
  totalTweets.push(data);

  // pause. On `iterator.next()` get the 3rd tweet and carry on.
  data = yield get('https://api.myjson.com/bins/29e3f');
  totalTweets.push(data);

  // log the tweets
  console.log(totalTweets);
};

// A generator function runner
let runGenerator = function (generatorFunction) {

  // recursive next()
  let next = function (err, arg) {

    // if error - throw and error
    if (err) return it.throw(err);

    // cache it.next(arg) as result
    var result = it.next(arg);

    // are we done?
    if (result.done) return;

    // result.value should be our callback() function from the XHR request
    if (typeof result.value == 'function') {
      // call next() as the callback()
      result.value(next);
    }
    else {
      // if the response isn't a function
      // pass it to next()
      next(null, result.value);
    }
  }

  // create the iterator
  let it = generatorFunction();
  return next();
}

// intiliase and pass in a generator function
runGenerator(callSomeGeneratorFunction);
```

## 제너레이터 여러개를 한꺼번에 사용하기
```javascript
function* concat(iter1, iter2) {
  for (var value of iter1) {
    yield value;
  }
  for (var value of iter2) {
    yield value;
  }
}

function* concat(iter1, iter2) {
  yield* iter1;
  yield* iter2;
}
```






